DOCUMENTAÇÃO TÉCNICA: MODELO DE SEQUENCIAMENTO DE LINHA (V1.0)1. VISÃO GERAL DO PROBLEMAO modelo implementado (LineSchedulingV1) resolve um problema de Dimensionamento de Lotes e Sequenciamento (Lot-Sizing and Scheduling) monomáquina, com as seguintes características principais:Setup Dependente da Sequência: O custo e o tempo de troca dependem do produto anterior ($j$) e do próximo ($i$).Horizonte de Planejamento Discreto: O tempo é dividido em períodos ($t$), que podem ser buckets pequenos ou grandes (o código permite configurar o tamanho do slot em horas).Conservação de Estado (Setup Carry-Over): O modelo rastreia o estado da máquina entre os períodos. Se o produto $i$ termina o período $t-1$, a máquina pode continuar produzindo $i$ em $t$ sem novo setup.Backlog e Inventário: A demanda pode ser atendida por produção no período, estoque (inventário) ou postergada (backlog com penalidade).Este modelo é uma variação do GLSP (General Lot-Sizing and Scheduling Problem), formulado para garantir que, em cada microperíodo, ocorra no máximo uma troca de configuração (setup).2. FORMULAÇÃO MATEMÁTICAA implementação no PuLP segue rigorosamente a formulação descrita no PDF BPSA Production Scheduling - Model 0.3.pdf.2.1 Conjuntos e Índices$i, j \in P$: Conjunto de produtos (SKUs).$t \in T$: Conjunto de períodos de planejamento ($T_1, ..., T_m$). O período $T_0$ é um período "fantasma" usado para condições iniciais.2.2 Parâmetros (Dados de Entrada)$D_{it}$: Demanda do produto $i$ no período $t$.$C_t$: Capacidade de tempo disponível no período $t$ (em minutos).$T_t$: Tempo para produzir 1000 unidades (inverso da taxa de produção).$SC_{ij}$: Custo de setup para trocar de $j$ para $i$.$ST_{ij}$: Tempo de setup (downtime) para trocar de $j$ para $i$.2.3 Variáveis de DecisãoContínuas:$X_{it} \geq 0$: Quantidade produzida do produto $i$ no período $t$.$I_{it} \geq 0$: Nível de estoque do produto $i$ ao final de $t$.$B_{it} \geq 0$: Nível de backlog (demanda não atendida) do produto $i$ em $t$.Binárias:$Z_{ijt} \in \{0,1\}$: Variável de Setup. Indica se houve uma troca PARA o produto $i$, vindo DO produto $j$ no período $t$.$ZA_{it} \in \{0,1\}$: Variável de Setup Carry-Over. Indica se a máquina "trouxe" a configuração do produto $i$ do período anterior e continua apta a produzi-lo sem novo setup.2.4 Função ObjetivoO objetivo é minimizar uma soma ponderada de custos:$$\min \sum_{i,t} (W_{backlog} \cdot B_{it} + W_{inv} \cdot I_{it}) + \sum_{i,j,t} (SC_{ij} \cdot Z_{ijt})$$Na implementação (line_scheduling_v1.pyx), a função objetivo também penaliza o número de setups (multiplicando o custo por 2) para evitar trocas excessivas que não tragam benefício real, e aplica pesos diferentes para Backlog vs. Inventário.3. RESTRIÇÕES (O Núcleo do Modelo)3.1 Balanceamento de Massa (Restrição 1)Garante que a Demanda = Produção + Estoque Anterior - Estoque Atual + Variação de Backlog.$$X_{it} + I_{i(t-1)} - I_{it} + B_{it} - B_{i(t-1)} = D_{it}$$Código: Linhas 73-77.3.2 Lógica de Setup e Produção (Restrições 2 e 3)Só é permitido produzir $i$ se houver um setup para $i$ ($Z$) ou se a configuração já estava em $i$ ($ZA$).$$X_{it} \le M \cdot (\sum_{j} Z_{ijt} + ZA_{it})$$Código: Linhas 78-84.Além disso, forçamos que um setup só ocorra se houver produção em $t$ ou $t+1$ (para evitar setups "fantasmas"):$$\sum_{j} Z_{ijt} \le X_{it} + X_{i(t+1)}$$Código: Linhas 85-88.3.3 Capacidade (Restrição 4)O tempo total gasto (Produção + Tempos de Setup) não pode exceder a capacidade do período.$$\sum_{i} (X_{it} \cdot T_t) + \sum_{i,j} (Z_{ijt} \cdot ST_{ji}) \le C_t$$Código: Linhas 89-97.3.4 Controle de Sequenciamento (GLSP - Restrições 5 a 9)Esta é a parte crítica que gerencia a sequência $j \to i$:Único Setup por Período: No máximo uma troca ocorre por período.$$\sum_{i,j} Z_{ijt} \le 1$$Código: Linhas 98-101.Único Estado (Carry-Over): A máquina só pode estar configurada para um produto no início do período.$$\sum_{i} ZA_{it} \le 1$$Código: Linhas 102-103.Continuidade do Estado (Linking Constraints):Para manter o estado $i$ em $t$ ($ZA_{it}=1$), a máquina deve ter terminado $t-1$ no estado $i$. Isso ocorre se houve um setup para $i$ em $t-1$ OU se já estava em $i$ (carry-over) em $t-1$.Restrições 7 e 8 garantem matematicamente essa consistência.Conexão de Setup: Se trocamos de $j$ para $i$ no período $t$ ($Z_{ijt}=1$), o estado da máquina (carry-over) devia ser $j$.$$Z_{ijt} \le ZA_{jt}$$Código: Linhas 119-121.3.5 Condições Iniciais (Restrições 11 e 12)O modelo fixa as variáveis no período $T_0$ para zero, exceto o setup inicial.Lê-se o produto inicial da linha (ex: CAABSKP... no arquivo CSV).Define-se $ZA_{k,0} = 1$ para esse produto $k$ e $0$ para os outros. Isso força que o primeiro setup do horizonte de planejamento deva ser compatível com o produto que já está na máquina.4. ESTRUTURA DAS INSTÂNCIAS (INPUTS)O sistema ingere dados de planilhas CSV para popular os parâmetros do modelo. Veja como cada arquivo se conecta ao código:A. Production Need (...Production Need.csv)Conteúdo: Tabela com colunas de datas (ex: 2025-10-31, 2025-11-01) e linhas por SKU.Mapeamento: O código lê essas datas e as agrupa em "Períodos" ($T_1, T_2...$) com base no parâmetro planning_hours_slot.No Modelo: Preenche o parâmetro $D_{it}$ (Demanda). O código soma as demandas diárias que caem dentro de um mesmo período $T$.B. Production Rate (...Production Rate.csv)Conteúdo: Capacidade da linha (ex: 2000 latas/minuto ou unidades/tempo) por dia.Mapeamento: O código converte essa taxa para "Tempo para produzir 1000 unidades".No Modelo: Define o parâmetro $T_t$.Cálculo: $T_t = 1 / \text{Rate}$.Define também $C_t$ (Capacidade total em minutos do período) baseada na duração do slot de tempo.C. Initial Setup (...Initial Setup.csv)Conteúdo: Indica qual SKU está na linha no momento zero.No Modelo: Usado para fixar a variável binária $ZA_{i0}$ (Restrição 12). Se a linha começa com o Produto A, então $ZA_{A,0} = 1$. Qualquer produção de Produto B no primeiro período exigirá um setup $Z_{B,A,1}$ (custo de A para B).D. Setup Matrix (Implícito/Calculado)Embora não tenha um CSV anexado apenas para a matriz, o código possui funções _gen_setup_cost_matrix e _gen_setup_time_matrix.Ele lê custos de troca entre SKUs. Se sku_from != sku_to, atribui custo e tempo. O código calcula o tempo baseado em multiplicadores definidos na configuração de execução (optz_run).5. DETALHES DE IMPLEMENTAÇÃO (Python/PuLP)Geração de Períodos Dinâmicos:O método _gen_periods cria a discretização do tempo. Se você definir slots de 4 horas, ele quebra o horizonte de dias do CSV em blocos de 4h ($T_1, T_2, ...$).Importante: Buckets menores aumentam a precisão do sequenciamento, mas aumentam drasticamente o número de variáveis binárias ($Z_{ijt}$), tornando a resolução via Gurobi/CBC mais lenta.Solver:O código tenta usar Gurobi (com licença). Se não encontrar, faz fallback para CBC (PuLP default).Os parâmetros do Gurobi estão tunados para MIPFocus=2 (foco em otimalidade) e heurísticas agressivas (0.5), indicando que encontrar uma solução factível rápida é prioritário.Variáveis Dummy/Segurança:Como o PuLP pode ter problemas com caracteres especiais em nomes de produtos, o código usa um mapa interno (_secure_label) para renomear produtos para PROD1, PROD2, etc. durante a otimização.Saída de Dados:O método build_results decodifica as variáveis do solver de volta para objetos de negócio (ProductionItem, SetupItem), facilitando a geração de relatórios ou gráficos de Gantt posteriores.RESUMO PARA O USUÁRIOEste modelo é uma ferramenta robusta para planejamento tático de curto/médio prazo. Ele responde à pergunta: "Qual a sequência de produção que minimiza meus custos de troca e atrasos, respeitando a capacidade da linha e o estado atual da máquina?". A complexidade computacional é alta ($O(n^2 \cdot t)$ variáveis binárias), então o ajuste do tamanho do período ($C_t$) é a principal alavanca de performance.